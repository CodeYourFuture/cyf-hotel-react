import { assign, clean, createMarkupForStyles, forEach, hashObject, hashString, keys, map, reduce } from 'emotion-utils';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance
- 'polyfills' on server side

// usage

import StyleSheet from 'glamor/lib/sheet'
let styleSheet = new StyleSheet()

styleSheet.inject()
- 'injects' the stylesheet into the page (or into memory if on server)

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/

function last(arr) {
  return arr[arr.length - 1];
}

function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }

  // this weirdness brought to you by firefox
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}

var isBrowser = typeof window !== 'undefined';
var isDev = process.env.NODE_ENV === 'development' || !process.env.NODE_ENV; // (x => (x === 'development') || !x)(process.env.NODE_ENV)
var isTest = process.env.NODE_ENV === 'test';

var oldIE = function () {
  if (isBrowser) {
    var div = document.createElement('div');
    div.innerHTML = '<!--[if lt IE 10]><i></i><![endif]-->';
    return div.getElementsByTagName('i').length === 1;
  }
}();

function makeStyleTag() {
  var tag = document.createElement('style');
  tag.type = 'text/css';
  tag.setAttribute('data-emotion', '');
  tag.appendChild(document.createTextNode(''));(document.head || document.getElementsByTagName('head')[0]).appendChild(tag);
  return tag;
}

var StyleSheet = function () {
  function StyleSheet() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$speedy = _ref.speedy,
        speedy = _ref$speedy === undefined ? !isDev && !isTest : _ref$speedy,
        _ref$maxLength = _ref.maxLength,
        maxLength = _ref$maxLength === undefined ? isBrowser && oldIE ? 4000 : 65000 : _ref$maxLength;

    _classCallCheck(this, StyleSheet);

    this.isSpeedy = speedy; // the big drawback here is that the css won't be editable in devtools
    this.sheet = undefined;
    this.tags = [];
    this.maxLength = maxLength;
    this.ctr = 0;
  }

  StyleSheet.prototype.getSheet = function getSheet() {
    return sheetForTag(last(this.tags));
  };

  StyleSheet.prototype.inject = function inject() {
    var _this = this;

    if (this.injected) {
      throw new Error('already injected!');
    }
    if (isBrowser) {
      this.tags[0] = makeStyleTag();
    } else {
      // server side 'polyfill'. just enough behavior to be useful.
      this.sheet = {
        cssRules: [],
        insertRule: function insertRule(rule) {
          // enough 'spec compliance' to be able to extract the rules later
          // in other words, just the cssText field
          _this.sheet.cssRules.push({ cssText: rule });
        }
      };
    }
    this.injected = true;
  };

  StyleSheet.prototype.speedy = function speedy(bool) {
    if (this.ctr !== 0) {
      // cannot change speedy mode after inserting any rule to sheet. Either call speedy(${bool}) earlier in your app, or call flush() before speedy(${bool})
      throw new Error('cannot change speedy now');
    }
    this.isSpeedy = !!bool;
  };

  StyleSheet.prototype._insert = function _insert(rule) {
    // this weirdness for perf, and chrome's weird bug
    // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule
    try {
      var sheet = this.getSheet();
      sheet.insertRule(rule, rule.indexOf('@import') !== -1 ? 0 : sheet.cssRules.length);
    } catch (e) {
      if (isDev) {
        // might need beter dx for this
        console.warn('illegal rule', rule); // eslint-disable-line no-console
      }
    }
  };

  StyleSheet.prototype.insert = function insert(rule) {
    if (isBrowser) {
      // this is the ultrafast version, works across browsers
      if (this.isSpeedy && this.getSheet().insertRule) {
        this._insert(rule);
      } else {
        // more browser weirdness. I don't even know
        // else if(this.tags.length > 0 && this.tags::last().styleSheet) {
        //   this.tags::last().styleSheet.cssText+= rule
        // }
        if (rule.indexOf('@import') !== -1) {
          var tag = last(this.tags);
          tag.insertBefore(document.createTextNode(rule), tag.firstChild);
        } else {
          last(this.tags).appendChild(document.createTextNode(rule));
        }
      }
    } else {
      // server side is pretty simple
      this.sheet.insertRule(rule, rule.indexOf('@import') !== -1 ? 0 : this.sheet.cssRules.length);
    }

    this.ctr++;
    if (isBrowser && this.ctr % this.maxLength === 0) {
      this.tags.push(makeStyleTag());
    }
    return this.ctr - 1;
  };

  StyleSheet.prototype.delete = function _delete(index) {
    // we insert a blank rule when 'deleting' so previously returned indexes remain stable
    return this.replace(index, '');
  };

  StyleSheet.prototype.flush = function flush() {
    if (isBrowser) {
      forEach(this.tags, function (tag) {
        return tag.parentNode.removeChild(tag);
      });
      this.tags = [];
      this.sheet = null;
      this.ctr = 0;
      // todo - look for remnants in document.styleSheets
    } else {
      // simpler on server
      this.sheet.cssRules = [];
    }
    this.injected = false;
  };

  StyleSheet.prototype.rules = function rules() {
    if (!isBrowser) {
      return this.sheet.cssRules;
    }
    var arr = [];
    forEach(this.tags, function (tag) {
      return arr.splice.apply(arr, [arr.length, 0].concat(Array.from(sheetForTag(tag).cssRules)));
    });
    return arr;
  };

  return StyleSheet;
}();

var sheet = new StyleSheet();
// üöÄ
sheet.inject();

var inserted = {};

function flush() {
  sheet.flush();
  inserted = {};
  sheet.inject();
}

// a simple cache to store generated obj styles
var registered = sheet.registered = {};

function register(spec) {
  if (!registered[spec.id]) {
    registered[spec.id] = spec;
  }
}

function _getRegistered(rule) {
  if (isLikeRule(rule)) {
    var ret = registered[idFor(rule)];
    if (ret == null) {
      throw new Error('[emotion] an unexpected rule cache miss occurred. This is probably a sign of multiple glamor instances in your app. See https://github.com/threepointone/glamor/issues/79');
    }
    return ret;
  }
  return rule;
}

function buildStyles(objs) {
  var computedClassName = '';
  var objectStyles = [];
  // This needs to be moved into the core
  forEach(objs, function (cls) {
    if (typeof cls === 'string') {
      var match = emotionClassRegex.exec(cls);
      if (match !== null && ruleCache[match[1]] !== undefined) {
        objectStyles.push(ruleCache[match[1]]);
      } else {
        computedClassName && (computedClassName += ' ');
        computedClassName += cls;
      }
    } else {
      objectStyles.push(cls);
    }
  });

  return { computedClassName: computedClassName, objectStyles: objectStyles };
}

function css(objs, vars, content) {
  if (!Array.isArray(objs)) {
    objs = [objs];
  }

  var _buildStyles = buildStyles(content ? objs.concat(content.apply(null, vars)) : objs),
      _buildStyles$computed = _buildStyles.computedClassName,
      computedClassName = _buildStyles$computed === undefined ? '' : _buildStyles$computed,
      _buildStyles$objectSt = _buildStyles.objectStyles,
      objectStyles = _buildStyles$objectSt === undefined ? [] : _buildStyles$objectSt;

  if (objectStyles.length) {
    computedClassName += ' ' + objStyle.apply(null, objectStyles).toString();
  }

  return computedClassName.trim();
}

function insertRawRule(css) {
  var spec = {
    id: hashString(css),
    css: css,
    type: 'raw'
  };

  register(spec);

  if (!inserted[spec.id]) {
    sheet.insert(spec.css);
    inserted[spec.id] = true;
  }
}

function injectGlobal(objs, vars, content) {
  var combined = content ? objs.concat(content.apply(null, vars)) : objs;
  var style = {};
  build(style, { src: combined });
  forEach(deconstructedStyleToCSS('', deconstruct(style)), function (rule) {
    insertRawRule(rule);
  });
}

function fontFace(objs, vars, content) {
  var combined = reduce(content ? objs.concat(content.apply(null, vars)) : objs, function (accum, item, i) {
    return assign(accum, item);
  }, {});

  insertRawRule('@font-face{' + createMarkupForStyles(combined) + '}');
}

function insertKeyframe(spec) {
  if (!inserted[spec.id]) {
    var inner = map(keys(spec.keyframes), function (kf) {
      return kf + ' {' + createMarkupForStyles(spec.keyframes[kf]) + '}';
    }).join('');

    forEach(['-webkit-', ''], function (prefix) {
      return sheet.insert('@' + prefix + 'keyframes ' + (spec.name + '_' + spec.id) + '{' + inner + '}');
    });

    inserted[spec.id] = true;
  }
}

function keyframes(objs, vars, content) {
  var _content$apply = content.apply(null, vars),
      kfs = _content$apply[0];

  var name = 'animation';

  var spec = {
    id: hashObject(kfs),
    type: 'keyframes',
    name: name,
    keyframes: kfs
  };

  register(spec);
  insertKeyframe(spec);
  return name + '_' + spec.id;
}

function hydrate(ids) {
  forEach(ids, function (id) {
    return inserted[id] = true;
  });
}

var cachedCss = typeof WeakMap !== 'undefined' ? multiIndexCache(_css) : _css;

// üç©
// https://github.com/threepointone/glamor
function objStyle() {
  for (var _len = arguments.length, rules = Array(_len), _key = 0; _key < _len; _key++) {
    rules[_key] = arguments[_key];
  }

  rules = clean(rules);
  if (!rules) {
    return nullrule;
  }

  return cachedCss(rules);
}

function _css(rules) {
  var style = {};
  build(style, { src: rules }); // mutative! but worth it.

  var spec = {
    id: hashObject(style),
    style: style,
    type: 'css'
  };
  return toRule(spec);
}

var emotionClassRegex = /^css-([a-zA-Z0-9]+)/;

// of shape { 'css-<id>': '' }
function isLikeRule(rule) {
  var ruleKeys = keys(rule);
  if (ruleKeys.length !== 1) {
    return false;
  }
  return !!emotionClassRegex.exec(ruleKeys[0]);
}

// extracts id from a { 'css-<id>': ''} like object
function idFor(rule) {
  var ruleKeys = keys(rule);
  if (ruleKeys.length !== 1) throw new Error('not a rule');
  var match = emotionClassRegex.exec(ruleKeys[0]);
  if (!match) throw new Error('not a rule');
  return match[1];
}

var parentSelectorRegex = /&/gm;

function selector(parentSelector) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (!parentSelector) {
    return path.replace(parentSelectorRegex, '');
  }
  if (!path) return parentSelector;

  var x = map(path.split(','), function (x) {
    return x.indexOf('&') >= 0 ? x.replace(parentSelectorRegex, parentSelector) : parentSelector + x;
  }).join(',');

  return x;
}

function deconstruct(style) {
  // we can be sure it's not infinitely nested here
  var plain = void 0;
  var selects = void 0;
  var medias = void 0;
  var supports = void 0;

  forEach(keys(style), function (key) {
    if (key.indexOf('&') >= 0) {
      selects = selects || {};
      selects[key] = deconstruct(style[key]).plain;
    } else if (key.indexOf('@media') === 0) {
      medias = medias || {};
      medias[key] = deconstruct(style[key]);
    } else if (key.indexOf('@supports') === 0) {
      supports = supports || {};
      supports[key] = deconstruct(style[key]);
    } else {
      plain = plain || {};

      plain[key] = style[key];
    }
  });
  return { plain: plain, selects: selects, medias: medias, supports: supports };
}

function deconstructedStyleToCSS(id, style) {
  var plain = style.plain,
      selects = style.selects,
      medias = style.medias,
      supports = style.supports;

  var css = [];

  if (plain) {
    css.push(selector(id) + '{' + createMarkupForStyles(plain) + '}');
  }
  if (selects) {
    forEach(keys(selects), function (key) {
      return css.push(selector(id, key) + '{' + createMarkupForStyles(selects[key]) + '}');
    });
  }
  if (medias) {
    forEach(keys(medias), function (key) {
      return css.push(key + '{' + deconstructedStyleToCSS(id, medias[key]).join('') + '}');
    });
  }
  if (supports) {
    forEach(keys(supports), function (key) {
      return css.push(key + '{' + deconstructedStyleToCSS(id, supports[key]).join('') + '}');
    });
  }
  return css;
}

// and helpers to insert rules into said sheet
function insert(spec) {
  if (!inserted[spec.id]) {
    inserted[spec.id] = true;
    var deconstructed = deconstruct(spec.style);
    map(deconstructedStyleToCSS('.css-' + spec.id, deconstructed), function (cssRule) {
      return sheet.insert(cssRule);
    });
  }
}

// todo - perf
var ruleCache = {};

function toRule(spec) {
  var _ret;

  register(spec);
  insert(spec);
  if (ruleCache[spec.id]) {
    return ruleCache[spec.id];
  }

  var ret = (_ret = {}, _ret['css-' + spec.id] = '', _ret);
  Object.defineProperty(ret, 'toString', {
    enumerable: false,
    value: function value() {
      return 'css-' + spec.id;
    }
  });
  ruleCache[spec.id] = ret;
  return ret;
}

function isFragment(key) {
  return key.indexOf('$') === 0;
}

function isSelector(val) {
  return typeof val === 'object';
}

function joinSelectors(a, b) {
  var as = map(a.split(','), function (a) {
    return !(a.indexOf('&') >= 0) ? '&' + a : a;
  });
  var bs = map(b.split(','), function (b) {
    return !(b.indexOf('&') >= 0) ? '&' + b : b;
  });

  return reduce(bs, function (arr, b) {
    return arr.concat(map(as, function (a) {
      return b.replace(parentSelectorRegex, a);
    }));
  }, []).join(',');
}

function joinMediaQueries(a, b) {
  return a ? '@media ' + a.substring(6) + ' and ' + b.substring(6) : b;
}

function isMediaQuery(key) {
  return key.indexOf('@media') === 0;
}

function isSupports(key) {
  return key.indexOf('@supports') === 0;
}

function joinSupports(a, b) {
  return a ? '@supports ' + a.substring(9) + ' and ' + b.substring(9) : b;
}

// flatten a nested array
function flatten(inArr) {
  var arr = [];
  forEach(inArr, function (val) {
    if (Array.isArray(val)) arr = arr.concat(flatten(val));else arr = arr.concat(val);
  });

  return arr;
}

// mutable! modifies dest.
function build(dest, _ref) {
  var _ref$selector = _ref.selector,
      selector = _ref$selector === undefined ? '' : _ref$selector,
      _ref$mq = _ref.mq,
      mq = _ref$mq === undefined ? '' : _ref$mq,
      _ref$supp = _ref.supp,
      supp = _ref$supp === undefined ? '' : _ref$supp,
      _ref$src = _ref.src,
      src = _ref$src === undefined ? [{}] : _ref$src;

  if (!Array.isArray(src)) {
    src = [src];
  }
  src = flatten(src);
  forEach(src, function (_src) {
    if (isLikeRule(_src)) {
      var reg = _getRegistered(_src);
      if (reg.type !== 'css') {
        throw new Error('cannot merge this rule');
      }
      _src = reg.style;
    }
    _src = clean(_src);
    if (_src && _src.composes) {
      build(dest, { selector: selector, mq: mq, supp: supp, src: _src.composes });
    }

    forEach(keys(_src || {}), function (key) {
      // replace fragments
      if (isFragment(key)) {
        var fragment = _src[key];

        if (typeof fragment === 'string') {
          var match = emotionClassRegex.exec(fragment);
          if (match !== null && registered[match[1]]) {
            var _reg = registered[match[1]];
            if (_reg.type !== 'css') {
              throw new Error('cannot merge this rule');
            }
            build(dest, {
              selector: selector,
              mq: mq,
              supp: supp,
              src: _reg.style
            });
          }
        } else {
          build(dest, {
            selector: selector,
            mq: mq,
            supp: supp,
            src: fragment
          });
        }
      } else if (isMediaQuery(key)) {
        build(dest, {
          selector: selector,
          mq: joinMediaQueries(mq, key),
          supp: supp,
          src: _src[key]
        });
      } else if (isSupports(key)) {
        build(dest, {
          selector: selector,
          mq: mq,
          supp: joinSupports(supp, key),
          src: _src[key]
        });
      } else if (key === 'composes') {
        // ignore, we already dealt with it
      } else if (isSelector(_src[key])) {
        build(dest, {
          selector: joinSelectors(selector, key),
          mq: mq,
          supp: supp,
          src: _src[key]
        });
      } else {
        var _dest = dest;
        if (supp) {
          _dest[supp] = _dest[supp] || {};
          _dest = _dest[supp];
        }
        if (mq) {
          _dest[mq] = _dest[mq] || {};
          _dest = _dest[mq];
        }
        if (selector) {
          _dest[selector] = _dest[selector] || {};
          _dest = _dest[selector];
        }

        _dest[key] = _src[key];
      }
    });
  });
}

var nullrule = {
  // 'data-css-nil': ''
};

Object.defineProperty(nullrule, 'toString', {
  enumerable: false,
  value: function value() {
    return 'css-nil';
  }
});

var inputCaches = typeof WeakMap !== 'undefined' ? [nullrule, new WeakMap(), new WeakMap(), new WeakMap()] : [nullrule];

var warnedWeakMapError = false;

function multiIndexCache(fn) {
  return function (args) {
    if (inputCaches[args.length]) {
      var coi = inputCaches[args.length];
      var ctr = 0;
      while (ctr < args.length - 1) {
        if (!coi.has(args[ctr])) {
          coi.set(args[ctr], new WeakMap());
        }
        coi = coi.get(args[ctr]);
        ctr++;
      }
      if (coi.has(args[args.length - 1])) {
        var ret = coi.get(args[ctr]);

        if (registered[ret.toString().substring(4)]) {
          // make sure it hasn't been flushed
          return ret;
        }
      }
    }
    var value = fn(args);
    if (inputCaches[args.length]) {
      var _ctr = 0;
      var _coi = inputCaches[args.length];
      while (_ctr < args.length - 1) {
        _coi = _coi.get(args[_ctr]);
        _ctr++;
      }
      try {
        _coi.set(args[_ctr], value);
      } catch (err) {
        if ((process.env.NODE_ENV === 'development' || !process.env.NODE_ENV) && !warnedWeakMapError) {
          var _console;

          warnedWeakMapError = true;
          (_console = console).warn.apply(_console, ['failed setting the WeakMap cache for args:'].concat(args)); // eslint-disable-line no-console
          console.warn('this should NOT happen, please file a bug on the github repo.'); // eslint-disable-line no-console
        }
      }
    }
    return value;
  };
}

export { sheet, inserted, flush, css, injectGlobal, fontFace, keyframes, hydrate, objStyle, isLikeRule, idFor };
//# sourceMappingURL=index.es.js.map
