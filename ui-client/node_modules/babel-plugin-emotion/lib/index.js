'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //  weak


exports.getFilename = getFilename;
exports.replaceCssWithCallExpression = replaceCssWithCallExpression;
exports.buildStyledCallExpression = buildStyledCallExpression;
exports.buildStyledObjectCallExpression = buildStyledObjectCallExpression;
exports.replaceCssObjectCallExpression = replaceCssObjectCallExpression;

exports.default = function (babel) {
  var t = babel.types;


  return {
    name: 'emotion', // not required
    inherits: require('babel-plugin-syntax-jsx'),
    visitor: {
      Program: {
        enter: function enter(path, state) {
          state.importedNames = _extends({}, defaultImportedNames, state.opts.importedNames);
          state.file.metadata.modules.imports.forEach(function (_ref) {
            var source = _ref.source,
                imported = _ref.imported,
                specifiers = _ref.specifiers;

            if (source.indexOf('emotion') !== -1) {
              var importedNames = specifiers.filter(function (v) {
                return ['default', 'css', 'keyframes', 'injectGlobal', 'fontFace'].indexOf(v.imported) !== -1;
              }).reduce(function (acc, _ref2) {
                var _extends2;

                var imported = _ref2.imported,
                    local = _ref2.local;
                return _extends({}, acc, (_extends2 = {}, _extends2[imported === 'default' ? 'styled' : imported] = local, _extends2));
              }, defaultImportedNames);
              state.importedNames = _extends({}, importedNames, state.opts.importedNames);
            }
          });

          state.extractStatic =
          // path.hub.file.opts.filename !== 'unknown' ||
          state.opts.extractStatic;

          state.staticRules = [];

          state.insertStaticRules = function (staticRules) {
            var _state$staticRules;

            (_state$staticRules = state.staticRules).push.apply(_state$staticRules, staticRules);
          };
        },
        exit: function exit(path, state) {
          if (state.staticRules.length !== 0) {
            var toWrite = state.staticRules.join('\n').trim();
            var filenameArr = path.hub.file.opts.filename.split('.');
            filenameArr.pop();
            filenameArr.push('emotion', 'css');
            var cssFilename = filenameArr.join('.');
            var exists = _fs2.default.existsSync(cssFilename);
            path.node.body.unshift(t.importDeclaration([], t.stringLiteral('./' + (0, _path.basename)(cssFilename))));
            if (exists ? _fs2.default.readFileSync(cssFilename, 'utf8') !== toWrite : true) {
              if (!exists) {
                (0, _touch.touchSync)(cssFilename);
              }
              _fs2.default.writeFileSync(cssFilename, toWrite);
            }
          }
          if (state.cssPropIdentifier) {
            path.node.body.unshift(t.importDeclaration([t.importSpecifier(state.cssPropIdentifier, t.identifier('css'))], t.stringLiteral('emotion')));
          }
        }
      },
      JSXOpeningElement: function JSXOpeningElement(path, state) {
        (0, _cssProp2.default)(path, state, t);
      },
      CallExpression: function CallExpression(path, state) {
        if (path[visited]) {
          return;
        }
        try {
          if (t.isCallExpression(path.node.callee) && path.node.callee.callee.name === state.importedNames.styled || t.isMemberExpression(path.node.callee) && t.isIdentifier(path.node.callee.object) && path.node.callee.object.name === state.importedNames.styled) {
            var identifier = t.isCallExpression(path.node.callee) ? path.node.callee.callee : path.node.callee.object;
            path.replaceWith(buildStyledObjectCallExpression(path, state, identifier, t));
          }
          if (path.node.callee.name === state.importedNames.css && !path.node.arguments[1] && path.node.arguments[0]) {
            replaceCssObjectCallExpression(path, t.identifier(state.importedNames.css), t);
          }
        } catch (e) {
          throw path.buildCodeFrameError(e);
        }

        path[visited] = true;
      },
      TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
        if (
        // styled.h1`color:${color};`
        t.isMemberExpression(path.node.tag) && path.node.tag.object.name === state.importedNames.styled) {
          path.replaceWith(buildStyledCallExpression(path.node.tag.object, t.stringLiteral(path.node.tag.property.name), path, state, t));
        } else if (
        // styled('h1')`color:${color};`
        t.isCallExpression(path.node.tag) && path.node.tag.callee.name === state.importedNames.styled) {
          path.replaceWith(buildStyledCallExpression(path.node.tag.callee, path.node.tag.arguments[0], path, state, t));
        } else if (t.isIdentifier(path.node.tag)) {
          if (path.node.tag.name === state.importedNames.css || path.node.tag === state.cssPropIdentifier) {
            replaceCssWithCallExpression(path, path.node.tag, state, t);
          } else if (path.node.tag.name === state.importedNames.keyframes) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, function (name, hash, src) {
              return '@keyframes ' + name + '-' + hash + ' { ' + src + ' }';
            });
          } else if (path.node.tag.name === state.importedNames.fontFace) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, function (name, hash, src) {
              return '@font-face {' + src + '}';
            }, true);
          } else if (path.node.tag.name === state.importedNames.injectGlobal) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, function (name, hash, src) {
              return src;
            }, true);
          }
        }
      }
    }
  };
};

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _touch = require('touch');

var _inline4 = require('./inline');

var _parser = require('./parser');

var _babelUtils = require('./babel-utils');

var _emotionUtils = require('emotion-utils');

var _cssProp = require('./css-prop');

var _cssProp2 = _interopRequireDefault(_cssProp);

var _astObject = require('./ast-object');

var _astObject2 = _interopRequireDefault(_astObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getFilename(path) {
  return path.hub.file.opts.filename === 'unknown' ? '' : path.hub.file.opts.filename;
}

function replaceCssWithCallExpression(path, identifier, state, t) {
  var staticCSSTextCreator = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (name, hash, src) {
    return '.' + name + '-' + hash + ' { ' + src + ' }';
  };
  var removePath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  try {
    var _inline = (0, _inline4.inline)(path.node.quasi, (0, _babelUtils.getIdentifierName)(path, t), 'css'),
        name = _inline.name,
        hash = _inline.hash,
        src = _inline.src;

    if (state.extractStatic && !path.node.quasi.expressions.length) {
      var cssText = staticCSSTextCreator(name, hash, src);

      var _parseCSS = (0, _parser.parseCSS)(cssText, true, getFilename(path)),
          staticCSSRules = _parseCSS.staticCSSRules;

      state.insertStaticRules(staticCSSRules);
      if (!removePath) {
        return path.replaceWith(t.stringLiteral(name + '-' + hash));
      }
      return path.replaceWith(t.identifier('undefined'));
    }

    var _parseCSS2 = (0, _parser.parseCSS)(src, false, getFilename(path)),
        styles = _parseCSS2.styles,
        composesCount = _parseCSS2.composesCount;

    if (!removePath) {
      path.addComment('leading', '#__PURE__');
    }

    var composeValues = path.node.quasi.expressions.slice(0, composesCount);
    var vars = path.node.quasi.expressions.slice(composesCount);
    path.replaceWith(t.callExpression(identifier, [t.arrayExpression(composeValues), t.arrayExpression(vars), t.functionExpression(t.identifier('createEmotionStyledRules'), vars.map(function (x, i) {
      return t.identifier('x' + i);
    }), t.blockStatement([t.returnStatement(t.arrayExpression([_astObject2.default.fromJS(styles, composesCount, t).toAST()]))]))]));
  } catch (e) {
    if (path) {
      throw path.buildCodeFrameError(e);
    }

    throw e;
  }
}

// babel-plugin-styled-components
// https://github.com/styled-components/babel-plugin-styled-components/blob/37a13e9c21c52148ce6e403100df54c0b1561a88/src/visitors/displayNameAndId.js#L49-L93

var findModuleRoot = function findModuleRoot(filename) {
  if (!filename || filename === 'unknown') {
    return null;
  }
  var dir = (0, _path.dirname)(filename);
  if (_fs2.default.existsSync((0, _path.join)(dir, 'package.json'))) {
    return dir;
  } else if (dir !== filename) {
    return findModuleRoot(dir);
  } else {
    return null;
  }
};

var FILE_HASH = 'emotion-file-hash';
var COMPONENT_POSITION = 'emotion-component-position';

var getFileHash = function getFileHash(state) {
  var file = state.file;
  // hash calculation is costly due to fs operations, so we'll cache it per file.

  if (file.get(FILE_HASH)) {
    return file.get(FILE_HASH);
  }
  var filename = file.opts.filename;
  // find module root directory
  var moduleRoot = findModuleRoot(filename);
  var filePath = moduleRoot && (0, _path.relative)(moduleRoot, filename).replace(_path.sep, '/');
  var moduleName = '';
  if (moduleRoot) {
    var packageJsonContent = _fs2.default.readFileSync((0, _path.join)(moduleRoot, 'package.json'));
    if (packageJsonContent) {
      try {
        moduleName = JSON.parse(packageJsonContent.toString()).name;
      } catch (e) {}
    }
  }
  var code = file.code;

  var fileHash = (0, _emotionUtils.hashArray)([moduleName, filePath, code]);
  file.set(FILE_HASH, fileHash);
  return fileHash;
};

var getNextId = function getNextId(state) {
  var id = state.file.get(COMPONENT_POSITION) || 0;
  state.file.set(COMPONENT_POSITION, id + 1);
  return id;
};

var getComponentId = function getComponentId(state) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'css';

  // Prefix the identifier with css- because CSS classes cannot start with a number
  // Also in snapshots with jest-glamor-react the hash will be replaced with an index
  return prefix + '-' + getFileHash(state) + getNextId(state);
};

function buildStyledCallExpression(identifier, tag, path, state, t) {
  var identifierName = (0, _babelUtils.getIdentifierName)(path, t);

  if (state.extractStatic && !path.node.quasi.expressions.length) {
    var _inline2 = (0, _inline4.inline)(path.node.quasi, identifierName, 'styled' // we don't want these styles to be merged in css``
    ),
        _name = _inline2.name,
        hash = _inline2.hash,
        _src = _inline2.src;

    var cssText = '.' + _name + '-' + hash + ' { ' + _src + ' }';

    var _parseCSS3 = (0, _parser.parseCSS)(cssText, true, getFilename(path)),
        staticCSSRules = _parseCSS3.staticCSSRules;

    state.insertStaticRules(staticCSSRules);
    return t.callExpression(identifier, [tag, t.stringLiteral(getComponentId(state, _name)), t.arrayExpression([t.stringLiteral(_name + '-' + hash)])]);
  }

  var _inline3 = (0, _inline4.inline)(path.node.quasi, identifierName, 'css'),
      src = _inline3.src,
      name = _inline3.name;

  path.addComment('leading', '#__PURE__');

  var _parseCSS4 = (0, _parser.parseCSS)(src, false, getFilename(path)),
      styles = _parseCSS4.styles,
      composesCount = _parseCSS4.composesCount;

  var objs = path.node.quasi.expressions.slice(0, composesCount);
  var vars = path.node.quasi.expressions.slice(composesCount);
  var args = [tag, t.stringLiteral(getComponentId(state, name)), t.arrayExpression(objs), t.arrayExpression(vars), t.functionExpression(t.identifier('createEmotionStyledRules'), vars.map(function (x, i) {
    return t.identifier('x' + i);
  }), t.blockStatement([t.returnStatement(_astObject2.default.fromJS(styles, composesCount, t).toAST())]))];

  return t.callExpression(identifier, args);
}

function buildStyledObjectCallExpression(path, state, identifier, t) {
  var tag = t.isCallExpression(path.node.callee) ? path.node.callee.arguments[0] : t.stringLiteral(path.node.callee.property.name);
  return t.callExpression(identifier, [tag, t.stringLiteral(getComponentId(state, (0, _inline4.getName)((0, _babelUtils.getIdentifierName)(path, t), 'css'))), t.arrayExpression(buildProcessedStylesFromObjectAST(path.node.arguments, path, t))]);
}

function buildProcessedStylesFromObjectAST(objectAST, path, t) {
  if (t.isObjectExpression(objectAST)) {
    return _astObject2.default.fromAST(objectAST, t, path).toAST();
  }
  if (t.isArrayExpression(objectAST)) {
    return t.arrayExpression(buildProcessedStylesFromObjectAST(objectAST.elements, path, t));
  }
  if (Array.isArray(objectAST)) {
    return (0, _emotionUtils.map)(objectAST, function (obj) {
      return buildProcessedStylesFromObjectAST(obj, path, t);
    });
  }

  return objectAST;
}

function replaceCssObjectCallExpression(path, identifier, t) {
  var argWithStyles = path.node.arguments[0];
  var styles = buildProcessedStylesFromObjectAST(argWithStyles, path, t);
  path.replaceWith(t.callExpression(identifier, [styles]));
}

var visited = Symbol('visited');

var defaultImportedNames = {
  styled: 'styled',
  css: 'css',
  keyframes: 'keyframes',
  injectGlobal: 'injectGlobal',
  fontFace: 'fontFace'
};