import { createElement } from 'react';
import { css } from 'emotion';
import * as emotion from 'emotion';
import { assign, map, omit, reduce } from 'emotion-utils';

/* global codegen */
var push = function push(obj, items) {
  return Array.prototype.push.apply(obj, items);
};

var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|accept|acceptCharset|accessKey|action|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable)|(on[A-Z].*)|((data|aria)-.*))$/;
var testOmitPropsOnStringTag = function testOmitPropsOnStringTag(key) {
  return reactPropsRegex.test(key);
};
var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
  return key !== 'theme' && key !== 'innerRef';
};

var index = function (tag, cls, objs) {
  var vars = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var content = arguments[4];

  if (!tag) {
    throw new Error('You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.');
  }

  var componentTag = tag.displayName || tag.name || 'Component';
  var spec = {
    vars: vars,
    content: content,
    objs: objs,
    tag: tag,
    cls: cls
  };
  var newSpec = tag.__emotion_spec !== undefined ? tag.__emotion_spec.concat(spec) : [spec];
  var localTag = newSpec[0].tag;

  var omitFn = typeof localTag === 'string' ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
  function Styled(props, context) {
    var getValue = function getValue(v) {
      if (v && typeof v === 'function') {
        if (v.__emotion_class !== undefined) {
          return '& .' + v.__emotion_class;
        }
        return v(props, context);
      }

      return v;
    };

    var finalObjs = [];

    push(finalObjs, reduce(newSpec, function (accum, spec) {
      push(accum, spec.objs);
      if (spec.content) {
        accum.push(spec.content.apply(null, map(spec.vars, getValue)));
      }
      accum.push(spec.cls);
      return accum;
    }, []));

    if (props.className) {
      push(finalObjs, props.className.split(' '));
    }

    var className = css(map(finalObjs, getValue));

    return createElement(localTag, omit(assign({}, props, {
      ref: props.innerRef,
      className: className
    }), omitFn));
  }

  Styled.displayName = 'styled(' + componentTag + ')';
  Styled.__emotion_spec = newSpec;
  Styled.__emotion_class = cls;
  return Styled;
};

export default index;

export * from 'emotion';
//# sourceMappingURL=index.es.js.map
